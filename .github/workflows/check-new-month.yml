name: Check new month data availability

on:
  schedule:
    - cron: "0 0,6,12,18 * * *"
  workflow_dispatch:
  push:
    branches:
      - features/feature-discord-local-workflow

jobs:
  check-availability:
    name: Check if previous month data is available
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v1
      
      - name: Calculate previous month
        id: month
        run: |
          # Calculer le mois prÃ©cÃ©dent
          PREVIOUS_MONTH=$(date -d "last month" +"%Y-m%m")
          PREVIOUS_MONTH_NAME=$(date -d "last month" +"%B %Y")
          FILE_NAME="deces-${PREVIOUS_MONTH}.txt.gz"
          
          echo "previous_month=${PREVIOUS_MONTH}" >> $GITHUB_OUTPUT
          echo "previous_month_name=${PREVIOUS_MONTH_NAME}" >> $GITHUB_OUTPUT
          echo "file_name=${FILE_NAME}" >> $GITHUB_OUTPUT
          
          echo "ðŸ“… Nous sommes en $(date +'%B %Y')"
          echo "ðŸ” Recherche des donnÃ©es de: ${PREVIOUS_MONTH_NAME}"
          echo "ðŸ“„ Fichier recherchÃ©: ${FILE_NAME}"
      
      - name: Check if already processed this month
        id: check_processed
        run: |
          MARKER_FILE=".github/workflows/.last_processed_month"
          
          if [ -f "$MARKER_FILE" ]; then
            LAST_PROCESSED=$(cat "$MARKER_FILE")
            echo "last_processed=${LAST_PROCESSED}" >> $GITHUB_OUTPUT
            
            if [ "$LAST_PROCESSED" = "${{ steps.month.outputs.previous_month }}" ]; then
              echo "already_processed=true" >> $GITHUB_OUTPUT
              echo "âœ… Mois ${{ steps.month.outputs.previous_month }} dÃ©jÃ  traitÃ©"
              exit 0
            else
              echo "already_processed=false" >> $GITHUB_OUTPUT
              echo "ðŸ”„ Nouveau mois dÃ©tectÃ©: ${{ steps.month.outputs.previous_month }}"
            fi
          else
            echo "already_processed=false" >> $GITHUB_OUTPUT
            echo "ðŸ†• Premier run, aucun mois traitÃ© prÃ©cÃ©demment"
          fi
      
      - name: Create artifacts file
        if: steps.check_processed.outputs.already_processed != 'true'
        run: |
          echo "ðŸ“ CrÃ©ation du fichier artifacts..."
          cat > artifacts << 'EOF'
          export GIT_ROOT = https://github.com/sebfournier95
          EOF
          
          echo "âœ… Fichier artifacts crÃ©Ã©"
          cat artifacts
      
      - name: ðŸ” Check and process new month data
        id: process
        if: steps.check_processed.outputs.already_processed != 'true'
        run: |
          echo "ðŸš€ Tentative de traitement du fichier ${{ steps.month.outputs.file_name }}..."
          
          if make clean config datagouv-to-upload FILES_TO_PROCESS=${FILES_TO_PROCESS} ; then
            
            echo "file_available=true" >> $GITHUB_OUTPUT
            echo "âœ… Fichier traitÃ© avec succÃ¨s"
            
            # RÃ©cupÃ©rer les statistiques
            FILE_PATH="backend/upload/${{ steps.month.outputs.file_name }}"
            if [ -f "$FILE_PATH" ]; then
              LINE_COUNT=$(zcat "$FILE_PATH" | wc -l)
              FILE_SIZE=$(du -h "$FILE_PATH" | awk '{print $1}')
              echo "line_count=${LINE_COUNT}" >> $GITHUB_OUTPUT
              echo "file_size=${FILE_SIZE}" >> $GITHUB_OUTPUT
              echo "ðŸ“Š ${LINE_COUNT} dÃ©cÃ¨s traitÃ©s (${FILE_SIZE})"
            fi
          else
            EXIT_CODE=$?
            echo "file_available=false" >> $GITHUB_OUTPUT
            echo "â³ Fichier pas encore disponible ou erreur de traitement (code: ${EXIT_CODE})"
            
            # VÃ©rifier si c'est juste que le fichier n'existe pas (et non une vraie erreur)
            if grep -q "no new file downloaded from datagouv" backend/tools/*.log 2>/dev/null; then
              echo "â„¹ï¸  Fichier simplement pas encore disponible"
            fi
            
            exit 0  # Ne pas faire Ã©chouer le workflow
          fi
        env:
          FILES_TO_PROCESS: ${{ steps.month.outputs.file_name }}
          
      - name: Mark month as processed
        if: steps.process.outputs.file_available == 'true'
        run: |
          mkdir -p .github/workflows
          echo "${{ steps.month.outputs.previous_month }}" > .github/workflows/.last_processed_month
          
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add .github/workflows/.last_processed_month
          git commit -m "ðŸ“Š Nouveau mois dÃ©tectÃ© et traitÃ©: ${{ steps.month.outputs.previous_month }}"
          git push
      
      - name: Send Discord notification
        if: steps.process.outputs.file_available == 'true'
        env:
          DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK }}
        run: |
          FILE_NAME="${{ steps.month.outputs.file_name }}"
          LINE_COUNT="${{ steps.process.outputs.line_count }}"
          FILE_SIZE="${{ steps.process.outputs.file_size }}"
          PREVIOUS_MONTH="${{ steps.month.outputs.previous_month }}"
          PREVIOUS_MONTH_NAME="${{ steps.month.outputs.previous_month_name }}"
          CURRENT_MONTH=$(date +'%B %Y')
          
          # Formater le nombre avec des espaces
          if [ -n "$LINE_COUNT" ]; then
            LINE_COUNT_FORMATTED=$(printf '%s' ${LINE_COUNT} | sed ':a;s/\B[0-9]\{3\}\>/\ &/;ta')
          else
            LINE_COUNT_FORMATTED="N/A"
          fi
          
          # Construire le payload JSON pour Discord
          PAYLOAD=$(cat <<EOF
          {
            "content": "@here ðŸŽ‰ Nouveau fichier de dÃ©cÃ¨s disponible et traitÃ© !",
            "embeds": [{
              "title": "ðŸ“Š Nouvelles donnÃ©es disponibles",
              "description": "Les donnÃ©es de **${PREVIOUS_MONTH_NAME}** ont Ã©tÃ© dÃ©tectÃ©es et traitÃ©es avec succÃ¨s (nous sommes en ${CURRENT_MONTH}).",
              "color": 3066993,
              "fields": [
                {
                  "name": "ðŸ“… Mois des donnÃ©es",
                  "value": "${PREVIOUS_MONTH_NAME}",
                  "inline": true
                },
                {
                  "name": "ðŸ“„ Fichier",
                  "value": "\`${FILE_NAME}\`",
                  "inline": true
                },
                {
                  "name": "ðŸ“Š Nombre de dÃ©cÃ¨s",
                  "value": "${LINE_COUNT_FORMATTED}",
                  "inline": true
                },
                {
                  "name": "ðŸ’¾ Taille",
                  "value": "${FILE_SIZE:-N/A}",
                  "inline": true
                },
                {
                  "name": "â° TraitÃ© le",
                  "value": "$(date +'%d/%m/%Y Ã  %H:%M:%S UTC')",
                  "inline": true
                },
                {
                  "name": "âœ… Statut",
                  "value": "DonnÃ©es indexÃ©es dans ES (dev)",
                  "inline": true
                },
                {
                  "name": "ðŸš€ Action sur votre serveur",
                  "value": "Lancez \`./run-local-update.sh ${PREVIOUS_MONTH}\` pour mettre Ã  jour votre index production local",
                  "inline": false
                }
              ],
              "footer": {
                "text": "deces-dataprep â€¢ DÃ©tection et traitement automatiques"
              },
              "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%S.000Z)"
            }]
          }
          EOF
          )
          
          # Envoyer Ã  Discord
          if curl -H "Content-Type: application/json" -d "$PAYLOAD" "$DISCORD_WEBHOOK"; then
            echo "âœ… Notification Discord envoyÃ©e"
          else
            echo "âš ï¸ Ã‰chec de l'envoi de la notification Discord"
          fi
